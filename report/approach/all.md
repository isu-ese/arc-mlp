# Approach - SIGMA

In this section, we go in depth into each step of our approach. Our approach is
presented in [@fig:approach]. [@Sec:parsing] explains how SIGMA parses input grammars.
[@Sec:trivial_merge] explains how SIGMA trivially merges the input grammars.
[@Sec:normalization] goes into depth on how SIGMA normalizes the trivially merged grammar.
[@Sec:similarity] explains how SIGMA calculates the similarity between two rules.
[@Sec:merging_similar] explains how SIGMA merges similar rules.

![Diagram of Approach](img/SIGMA-DFD.pdf){#fig:approach}

Our approach for merging grammars focuses on 7 steps.

1. Parse the input grammars.
2. Trivially merge the grammars into a single grammar.
3. Normalize the merged grammar.
4. Calculate the similarity between each pair of rules.
5. Merge the two most similar rules.
6. Repeat steps 3--5 until the two most similar rules are no longer similar.
7. Output the merged grammar.

## Parsing {#sec:parsing}

![Class Diagram of Grammar](img/grammar_class_diagram.pdf){#fig:grammar_class_diagram}

The parsing process transforms the textual form of each grammar into
an object oriented representation easier for our code to process.
A class diagram of this representation is in [@fig:grammar_class_diagram].
To do this transformation, SIGMA uses parsers generated by ANTLR
to extract an abstract syntax tree for each grammar. Each abstract
syntax tree is then converted into our representation. Finally, rules
with the same name are linked together within each grammar.

## Trivial Merge {#sec:trivial_merge}

A trivial merge between the start nodes of grammars is done rather easily. We simply
append the productions of the grammars to one another. We then create a new start node
with a production to each start node. Here is an example where we merge the grammars G1 and G2:

!grammar
```
<G1> ::= `a'

<G2> ::= `b'
```

\noindent After trivially merging, the result is:

!grammar
```
<Generated> ::= <G1> | <G2>

<G1> ::= `a'

<G2> ::= `b'
```

## Normalization {#sec:normalization}

For normalization, we normalized to a unique normal form where every production
was one of the following two forms:

!grammar
```
<A> ::= <B> | `b' | $\varepsilon$ | ...

<B> ::= <A> `a' ...
```

\noindent We chose these forms so that we would be able to easily compare similar productions.
We refer to the two forms as form 1 and form 2 respectively.

In both forms, the rules on the right hand side must not expand to the same form
as on the left hand side. We implemented this so that if productions are nested in different
ways, they normalized to the same form. Here is an example: Given grammar G1

!grammar
```
<A> ::= `a' <B>

<B> ::= `b' `c'
```

\noindent and grammar G2

!grammar
```
<A> ::= <B> `c'

<B> ::= `a' `b'
```

\noindent they both normalize to the same grammar.

!grammar
```
<A> ::= `a' `b' `c'
```

To normalize to the above form, we repeated 6 different processes until
the grammar stopped changing. These processes are to eliminate unused rules,
simplify the productions, merge equivalent rules, eliminate unit rules,
expand productions, and collapse compatible productions.

### Eliminate Unused Rules

To eliminate unused rules, we removed all rules that cannot be eventually
produced from the start rule. We did this by enumerating all used rules via
a depth first search and then retaining only those rules.

### Simplify

The simplify step was added to simplify our object representation.
We removed $\varepsilon$ items embedded inside terms and replaced
objects containing only one object with the object inside them.

### Merge equivalent Rules

In this step, we replace rules that have identical productions
with a single rule. The new rule is given a name derived from the
rules that were merged to create it. 

In the following example of this step, rules a and b are merged into
the rule a+b.

!grammar
~~~
<s> ::= <a> | <b>

<a> ::= `a' `b' <a>

<b> ::= `a' `b' <a>
~~~

Here it is after the rules are merged together.

!grammar
~~~
<s> ::= <a+b>

<a+b> ::= `a' `b' <a+b>
~~~

### Eliminate Unit Rules

This part of the normalization process is taken from the Chomksy Normal Form.
In this process, we eliminate all rules of one of the following two forms by
replacing each usage of one of these rules with their production.

!grammar
~~~
<a> ::= <b>

<a> ::= `a'
~~~

The Chomsky Normal Form differs in its unit rule removal in that it does not eliminate
rules of the second form. The reason we chose to eliminate the second form is so that
the simplification process can simplify rules of the following form.

!grammar
~~~
<a> ::= <b> `a' `b'

<b> ::= $\varepsilon$
~~~

## Measuring Rule Similarity {#sec:similarity}

The fourth step of SIGMA measures the similarity between every pair of productions.
This measure is used by the fifth step to determine which two rules to merge. In this
section, we lay out the two measures of similarity that we used for each of the two
forms of rules that our normalization step produces. If two productions are different
forms, we measure their similarity as 0.

### Term Similarity

The first measure of similarity that we used is for measuring the similarity between
two productions of form 1. For explaining our process, we use the following two productions.

!grammar
```
<$P_a$> ::= `a' <A> `b' `c'

<$P_b$> ::= <A> <B> `b' `a'
```

In the first step of measuring the similarity between two productions like this,
SIGMA aligns the productions as best as possible. This can be performed using
the Longest Common Subsequence (LCS) algorithm [@cormenIntroductionAlgorithms2001, pp. 350--355].

```
'a' <A>     'b'     'c'
    <A> <B> 'b' 'a'
```

Once we have aligned the two productions as best as possible, we count the number of aligned
terms and divide it by the total number of terms. The following formula also describes this:

$$S_1 = \frac{2|\textsc{LCS}(P_a, P_b)|}{|P_a| + |P_b|}$$

Applying the above formula to our example, `<A>` and `'b'` are each counted twice 
because they occur in both sequences of terms. The total number of terms across both productions is 8.
The total similarity score is $S_1 = \frac{4}{8} = .5$. 


### Alternatives Similairty

The second measure of similarity that we use is for measuring the similarity between two
productions of form 2. For explaining our process, we use the following two productions.

!grammar
```
<\(P_a\)> ::= `a' | <A> | `b' | `c'

<\(P_b\)> ::= <A> | <B> | `b' | `a'
```

Like the previous measure, we calculate the number of common alternatives before dividing by the total
number of alternatives. However, since the order of the alternatives doesn't matter, we use a different
approach to measure the common alternatives. We simply count an alternative as common to both if it is
both productions. The following formula describes how to calculate the similarity score using this method:

$$S_2 = \frac{2|P_a \cap P_b|}{|P_a| + |P_b|}$$

In our particular example, the common elements are `<A>`, `'a'`, and `'b'`. The total similarity
is then calculated as $\frac{2*3}{8} = .75$.

## Merging Similar Rules {#sec:merging_similar}

Once we have detected the two most similar productions using the above method,
we merge them together. Just like for measuring similarity, we have two different
processes for merging similar productions. These measures also differ for the forms
that we merge together. 

### Merging Similar Terms

To merge two productions of the first form, we use the LCS alignment produced while
measuring the similarity between the terms. We identify each pair of subsequences that do not align. In the previous example, these pairs of subsequences are (`'a'`, $\varepsilon$),
($\varepsilon$, `<B>`), and (`'a'`, `'c'`). We then replace each subsequence with a term that produces to either subsequence.
For example, the two sequences of terms mentioned earlier would merge to

!grammar
```
<$P_{a+b}$> ::= (`a' | $\varepsilon$) <A> ($\varepsilon$ | <B>) `b' (`c' | `a')
```

### Merging Similar Alternatives

Merging two productions of the second form is simpler than the first form.
The merged production produced simply contains all alternatives that are
in either constituent production. Our previous example would be merged to
the following

!grammar
```
<\(P_{a+b}\)> ::= `a' | <A> | <B> | `b' | `c'
```

