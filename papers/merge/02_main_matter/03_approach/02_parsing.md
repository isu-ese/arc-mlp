## Parsing {#sec:parsing}

![Grammar domain model.](images/paper/diagram.eps){#fig:grammar_class_diagram}

The initial step of the process is the translation of the textual representations of the grammars into an in-memory representation useful for manipulation. There are numerous forms of grammar representation, but in this paper we focus on the Antlr4 textual representation and an in-memory domain model based on BNF. The latter model is depicted in @fig:grammar_class_diagram.

To create instances of our model, we extracted information from the grammars using an ANTLR grammar parser generated by ANTLR. The parser creates an abstract syntax tree which is then converted into an instance of the domain model.

The ANTLR representation is not fully compatible with the domain model our approach depends upon. To resolve this, we removed or converted all non-bnf features except for dot, character range, character class, and not rules. The dot rule is a single character wildcard. Character ranges allow you to specify a range of characters. A character class only matches characters that fall into certain Unicode classes. The not rules match anything that isn't one of a set of items. For dot, character range, and character class rules, we converted them to special terminal symbols. We retained not rules, but made sure to extract them out as their own rules and their contents as well. For example

```
A: 'a' . ~('b' | 'c')
```

\noindent would be converted to

!grammar
```
<A> ::= `a' DOT <Generated-1>

<Generated-1> ::= \textasciitilde<Generated-2>

<Generated-2> ::= `b' | `c'
```

\noindent The not rules are ignored completely by our technique except for when detecting and merging duplicate rules.
